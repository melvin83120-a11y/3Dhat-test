<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Cube qui suit la tête avec curseurs</title>
<style>
body { margin:0; overflow:hidden; }
#videoElement { position:absolute; top:0; left:0; width:100vw; height:100vh; object-fit:cover; transform: scaleX(-1); z-index:0; }
canvas { position:absolute; top:0; left:0; z-index:1; }
#controls { position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.5); color:white; padding:10px; border-radius:10px; z-index:2; }
input[type=range]{ width:200px; }
</style>
</head>
<body>

<video id="videoElement" autoplay playsinline muted></video>

<div id="controls">
  <label for="scaleRange">Échelle :</label><br>
  <input type="range" id="scaleRange" min="0.1" max="3" step="0.1" value="1"><br><br>

  <label for="depthRange">Profondeur :</label><br>
  <input type="range" id="depthRange" min="0.5" max="15" step="0.1" value="2"><br><br>

  <label for="heightRange">Hauteur :</label><br>
  <input type="range" id="heightRange" min="0" max="1" step="0.01" value="0.3">
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>

<script>
// Webcam
const videoElement = document.getElementById('videoElement');
navigator.mediaDevices.getUserMedia({ video:true }).then(stream => { videoElement.srcObject = stream; });

// Three.js
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ alpha:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
renderer.domElement.style.transform="scaleX(-1)";
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(0,1,1).normalize();
scene.add(light);
camera.position.z = 2;

// Cube
const geometry = new THREE.BoxGeometry(0.5,0.5,0.5);
const material = new THREE.MeshNormalMaterial();
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

// Curseurs
const scaleRange = document.getElementById("scaleRange");
const depthRange = document.getElementById("depthRange");
const heightRange = document.getElementById("heightRange");

// Appliquer l’échelle initiale
cube.scale.set(parseFloat(scaleRange.value), parseFloat(scaleRange.value), parseFloat(scaleRange.value));

scaleRange.addEventListener("input", ()=>{ 
  const s = parseFloat(scaleRange.value);
  cube.scale.set(s,s,s);
});

// FaceMesh
const faceMesh = new FaceMesh({ locateFile:file => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });

// Valeur Z initiale pour éviter gros zoom
let currentZ = -2;

faceMesh.onResults(results=>{
  if(!results.multiFaceLandmarks[0]) return;
  const lm = results.multiFaceLandmarks[0];

  const leftEar = lm[234];
  const rightEar = lm[454];
  const forehead = lm[10];
  const chin = lm[152];
  const topHead = lm[10]; // sommet/front de la tête

  // Lire les valeurs actuelles des curseurs
  const offsetY = parseFloat(heightRange.value);   // hauteur
  const zoomFactor = parseFloat(depthRange.value); // profondeur

  // Position cube
  cube.position.x = (topHead.x - 0.5) * 8;
  cube.position.y = -(topHead.y - 0.5) * 3 + offsetY;

  // Gestion fluide de Z pour éviter gros zoom sur pitch
  const targetZ = -zoomFactor - topHead.z * 0.5; // topHead.z influence atténuée
  currentZ += (targetZ - currentZ) * 0.1; // lerp pour fluidité
  cube.position.z = currentZ;

  // Rotation cube
  cube.rotation.z = Math.atan2(leftEar.z - rightEar.z, rightEar.x - leftEar.x); // yaw
  cube.rotation.x = -Math.atan2(forehead.y - chin.y, forehead.z - chin.z);       // pitch
  cube.rotation.y = -Math.atan2(rightEar.y - leftEar.y, rightEar.x - leftEar.x);  // roll inversé

  renderer.render(scene,camera);
});

// MediaPipe Camera
const mpCamera = new Camera(videoElement, {
  onFrame: async()=>{ await faceMesh.send({image:videoElement}); },
  width:640,
  height:480
});
mpCamera.start();
</script>
</body>
</html>