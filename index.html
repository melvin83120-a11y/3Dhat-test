<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2113.6">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px 'Helvetica Neue'}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px 'Helvetica Neue'; min-height: 15.0px}
  </style>
</head>
<body>
<p class="p1">&lt;!DOCTYPE html&gt;</p>
<p class="p1">&lt;html lang="fr"&gt;</p>
<p class="p1">&lt;head&gt;</p>
<p class="p1">&lt;meta charset="UTF-8"&gt;</p>
<p class="p1">&lt;title&gt;Cube qui suit la tête avec curseurs&lt;/title&gt;</p>
<p class="p1">&lt;style&gt;</p>
<p class="p1">body { margin:0; overflow:hidden; }</p>
<p class="p1">#videoElement { position:absolute; top:0; left:0; width:100vw; height:100vh; object-fit:cover; transform: scaleX(-1); z-index:0; }</p>
<p class="p1">canvas { position:absolute; top:0; left:0; z-index:1; }</p>
<p class="p1">#controls { position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.5); color:white; padding:10px; border-radius:10px; z-index:2; }</p>
<p class="p1">input[type=range]{ width:200px; }</p>
<p class="p1">&lt;/style&gt;</p>
<p class="p1">&lt;/head&gt;</p>
<p class="p1">&lt;body&gt;</p>
<p class="p2"><br></p>
<p class="p1">&lt;video id="videoElement" autoplay playsinline muted&gt;&lt;/video&gt;</p>
<p class="p2"><br></p>
<p class="p1">&lt;div id="controls"&gt;</p>
<p class="p1"><span class="Apple-converted-space">  </span>&lt;label for="scaleRange"&gt;Échelle :&lt;/label&gt;&lt;br&gt;</p>
<p class="p1"><span class="Apple-converted-space">  </span>&lt;input type="range" id="scaleRange" min="0.1" max="3" step="0.1" value="1"&gt;&lt;br&gt;&lt;br&gt;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>&lt;label for="depthRange"&gt;Profondeur :&lt;/label&gt;&lt;br&gt;</p>
<p class="p1"><span class="Apple-converted-space">  </span>&lt;input type="range" id="depthRange" min="0.5" max="15" step="0.1" value="2"&gt;&lt;br&gt;&lt;br&gt;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>&lt;label for="heightRange"&gt;Hauteur :&lt;/label&gt;&lt;br&gt;</p>
<p class="p1"><span class="Apple-converted-space">  </span>&lt;input type="range" id="heightRange" min="0" max="1" step="0.01" value="0.3"&gt;</p>
<p class="p1">&lt;/div&gt;</p>
<p class="p2"><br></p>
<p class="p1">&lt;script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"&gt;&lt;/script&gt;</p>
<p class="p1">&lt;script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"&gt;&lt;/script&gt;</p>
<p class="p1">&lt;script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"&gt;&lt;/script&gt;</p>
<p class="p2"><br></p>
<p class="p1">&lt;script&gt;</p>
<p class="p1">// Webcam</p>
<p class="p1">const videoElement = document.getElementById('videoElement');</p>
<p class="p1">navigator.mediaDevices.getUserMedia({ video:true }).then(stream =&gt; { videoElement.srcObject = stream; });</p>
<p class="p2"><br></p>
<p class="p1">// Three.js</p>
<p class="p1">const scene = new THREE.Scene();</p>
<p class="p1">const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);</p>
<p class="p1">const renderer = new THREE.WebGLRenderer({ alpha:true });</p>
<p class="p1">renderer.setSize(window.innerWidth, window.innerHeight);</p>
<p class="p1">document.body.appendChild(renderer.domElement);</p>
<p class="p1">renderer.domElement.style.transform="scaleX(-1)";</p>
<p class="p1">const light = new THREE.DirectionalLight(0xffffff,1);</p>
<p class="p1">light.position.set(0,1,1).normalize();</p>
<p class="p1">scene.add(light);</p>
<p class="p1">camera.position.z = 2;</p>
<p class="p2"><br></p>
<p class="p1">// Cube</p>
<p class="p1">const geometry = new THREE.BoxGeometry(0.5,0.5,0.5);</p>
<p class="p1">const material = new THREE.MeshNormalMaterial();</p>
<p class="p1">const cube = new THREE.Mesh(geometry, material);</p>
<p class="p1">scene.add(cube);</p>
<p class="p2"><br></p>
<p class="p1">// Curseurs</p>
<p class="p1">const scaleRange = document.getElementById("scaleRange");</p>
<p class="p1">const depthRange = document.getElementById("depthRange");</p>
<p class="p1">const heightRange = document.getElementById("heightRange");</p>
<p class="p2"><br></p>
<p class="p1">// Appliquer l’échelle initiale</p>
<p class="p1">cube.scale.set(parseFloat(scaleRange.value), parseFloat(scaleRange.value), parseFloat(scaleRange.value));</p>
<p class="p2"><br></p>
<p class="p1">scaleRange.addEventListener("input", ()=&gt;{<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>const s = parseFloat(scaleRange.value);</p>
<p class="p1"><span class="Apple-converted-space">  </span>cube.scale.set(s,s,s);</p>
<p class="p1">});</p>
<p class="p2"><br></p>
<p class="p1">// FaceMesh</p>
<p class="p1">const faceMesh = new FaceMesh({ locateFile:file =&gt; `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });</p>
<p class="p1">faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });</p>
<p class="p2"><br></p>
<p class="p1">// Valeur Z initiale pour éviter gros zoom</p>
<p class="p1">let currentZ = -2;</p>
<p class="p2"><br></p>
<p class="p1">faceMesh.onResults(results=&gt;{</p>
<p class="p1"><span class="Apple-converted-space">  </span>if(!results.multiFaceLandmarks[0]) return;</p>
<p class="p1"><span class="Apple-converted-space">  </span>const lm = results.multiFaceLandmarks[0];</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>const leftEar = lm[234];</p>
<p class="p1"><span class="Apple-converted-space">  </span>const rightEar = lm[454];</p>
<p class="p1"><span class="Apple-converted-space">  </span>const forehead = lm[10];</p>
<p class="p1"><span class="Apple-converted-space">  </span>const chin = lm[152];</p>
<p class="p1"><span class="Apple-converted-space">  </span>const topHead = lm[10]; // sommet/front de la tête</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Lire les valeurs actuelles des curseurs</p>
<p class="p1"><span class="Apple-converted-space">  </span>const offsetY = parseFloat(heightRange.value); <span class="Apple-converted-space">  </span>// hauteur</p>
<p class="p1"><span class="Apple-converted-space">  </span>const zoomFactor = parseFloat(depthRange.value); // profondeur</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Position cube</p>
<p class="p1"><span class="Apple-converted-space">  </span>cube.position.x = (topHead.x - 0.5) * 8;</p>
<p class="p1"><span class="Apple-converted-space">  </span>cube.position.y = -(topHead.y - 0.5) * 3 + offsetY;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Gestion fluide de Z pour éviter gros zoom sur pitch</p>
<p class="p1"><span class="Apple-converted-space">  </span>const targetZ = -zoomFactor - topHead.z * 0.5; // topHead.z influence atténuée</p>
<p class="p1"><span class="Apple-converted-space">  </span>currentZ += (targetZ - currentZ) * 0.1; // lerp pour fluidité</p>
<p class="p1"><span class="Apple-converted-space">  </span>cube.position.z = currentZ;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Rotation cube</p>
<p class="p1"><span class="Apple-converted-space">  </span>cube.rotation.z = Math.atan2(leftEar.z - rightEar.z, rightEar.x - leftEar.x); // yaw</p>
<p class="p1"><span class="Apple-converted-space">  </span>cube.rotation.x = -Math.atan2(forehead.y - chin.y, forehead.z - chin.z); <span class="Apple-converted-space">      </span>// pitch</p>
<p class="p1"><span class="Apple-converted-space">  </span>cube.rotation.y = -Math.atan2(rightEar.y - leftEar.y, rightEar.x - leftEar.x);<span class="Apple-converted-space">  </span>// roll inversé</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>renderer.render(scene,camera);</p>
<p class="p1">});</p>
<p class="p2"><br></p>
<p class="p1">// MediaPipe Camera</p>
<p class="p1">const mpCamera = new Camera(videoElement, {</p>
<p class="p1"><span class="Apple-converted-space">  </span>onFrame: async()=&gt;{ await faceMesh.send({image:videoElement}); },</p>
<p class="p1"><span class="Apple-converted-space">  </span>width:640,</p>
<p class="p1"><span class="Apple-converted-space">  </span>height:480</p>
<p class="p1">});</p>
<p class="p1">mpCamera.start();</p>
<p class="p1">&lt;/script&gt;</p>
<p class="p1">&lt;/body&gt;</p>
<p class="p1">&lt;/html&gt;</p>
</body>
</html>
